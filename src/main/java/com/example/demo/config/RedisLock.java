package com.example.demo.config;

import com.example.demo.model.Lock;

/**
 * 使用redis分布式锁涉及几个重要参数
 * 锁的名称lockname 代表这个锁在redis中的key
 * key的过期时间，时间的格式
 * 
 * ================================
 这样在获取锁的时候就能够保证设置 Redis 值和过期时间的原子性，避免前面提到的两次 Redis 操作期间出现意外而导致的锁不能释放的问题。但是这样还是可能会存在一个问题，考虑如下的场景顺序：

线程T1获取锁
线程T1执行业务操作，由于某些原因阻塞了较长时间
锁自动过期，即锁自动释放了

线程T2获取锁
线程T1业务操作完毕，释放锁（其实是释放的线程T2的锁）

按照这样的场景顺序，线程T2的业务操作实际上就没有锁提供保护机制了。所以，每个线程释放锁的时候只能释放自己的锁，即锁必须要有一个拥有者的标记，并且也需要保证释放锁的原子性操作。

因此在获取锁的时候，可以生成一个随机不唯一的串放入当前线程中，然后再放入 Redis 。释放锁的时候先判断锁对应的值是否与线程中的值相同，相同时才做删除操作。

 * ====================================
 * 在集群模式的极端情况下，还是可能会存在一些问题，比如如下的场景顺序（ 本文暂时不深入开展 ）：
线程T1获取锁成功
Redis 的master节点挂掉，slave自动顶上
线程T2获取锁，会从slave节点上去判断锁是否存在，由于Redis的master slave复制是异步的，所以此时线程T2可能成功获取到锁
 * 
 * */
public interface RedisLock {
	
	public boolean tryLock(Lock lock) ;
}
